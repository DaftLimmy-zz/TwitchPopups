<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">

    <script type="text/javascript">

        // Change Limmy to your Twitch channel
        const twitchChannel = 'Limmy';

        // Your alert background. Default is a vibrant green
        const alertBg = '#00AA00';

        // Hotseat background colour. Default is a fiery, fiery orange.
        const hotseatBg = '#aa1100';

        // The emoji that surrounds the hotseat messages.
        const hotseatEmoji = 'ðŸ”¥';

        // Follow the instructions in README.md

    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="jquery-3.4.1.min.js"></script>
    <script src="tmi.min.js"></script>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Open Sans Condensed:700">

	<style>
		html, body {
			height: 100%;
			margin: 0;
			overflow: hidden;
		}

		#popupbox {
			position: absolute;
			bottom: 20px;
			left: 20px;
			right: 20px;
			overflow: hidden;
			transform: translate3d(0, calc(100% + 20px), 0);
			opacity: 0;
			transition: all .4s ease-out;
		}

		#popupbox.show {
			transform: none;
			opacity: 1;
		}

		#popuptext {
			display: inline-block;
			white-space: nowrap;
			font-family: 'Open Sans Condensed';
			font-weight: 700;
			color: white;
			font-size: 60px;
			margin: 0;
			padding: 0 15px;
		}

		#popuptext.scrolling {
			animation: marquee 5s linear infinite alternate;
		}
	</style>

</head>

<body>

	<div id="popupbox">
	    <h1 id="popuptext"></h1>		
	</div>

</body>
    
<script type="text/javascript">
    const opts = {
        channels: [
            twitchChannel
        ]
    };

    // Create a client with our options defined at the top of the file
    let client = new tmi.client(opts);

    // Register our event handlers (defined below)
    client.on('message', onMessageHandler);
    client.on('connected', onConnectedHandler);

    // Connect to Twitch:
    client.connect();

    //
    //
    // =========
    // ANIMATION
    // =========    
    

    // Hotseat stuff
    let hotSeatUser = "";
    let hotSeatIsOn = false;
    const popupBox = document.getElementById('popupbox');
    const popupText = document.getElementById('popuptext');
    const marqueeStylesheet = document.createElement('style');
    document.head.appendChild(marqueeStylesheet);

    // Called every time a message comes in
    function onMessageHandler(target, context, msg, self) {
        // Remove whitespace from chat message
        const commandName = msg.trim();
        
        // If the command is known, let's execute it

            if (context.mod || (context["badges-raw"] != null && context["badges-raw"].startsWith("broadcaster"))) {
                if (commandName.startsWith("!alert ")) {
                    popupText.style.backgroundColor = alertBg;
                    setText(commandName.substr(7).toUpperCase());
                    doAnimation();
                } else if (commandName.startsWith("!delete")) {
                  deleteAnimation();
                } else if (commandName.startsWith("!hotseat ")) {
                  hotSeatIsOn = true;
                  hotSeatUser = commandName.replace(/!hotseat @?/, '').toLowerCase();
                  popupText.style.backgroundColor = hotseatBg;
                  setText(`${hotseatEmoji} ${hotSeatUser.toUpperCase()} IS IN THE HOTSEAT ${hotseatEmoji}`);
                  doAnimation();
                }
            }

            if (hotSeatIsOn) {
                if (context.username == hotSeatUser){
                    setText(`${hotseatEmoji} ${context['display-name']}: ${commandName} ${hotseatEmoji}`);
                    doHotseatAnimation();
                }
            }

    }

    const setText = (text) => {
        popupText.innerText = text;
        const isOverflowing = popupText.offsetWidth > popupBox.offsetWidth;
        // Offset at either end of the scroll so you have time to read the start and end
        const scrollingOffset = 75;
        if (isOverflowing) {
            marqueeStylesheet.sheet.insertRule(`@keyframes marquee {
                0% {
                    transform: translate3d(${scrollingOffset}px, 0, 0);
                }
                100% {
                    transform: translate3d(${popupBox.offsetWidth - popupText.offsetWidth - scrollingOffset}px, 0, 0);
                }
            }`, 0);
        }
        popupText.classList.toggle('scrolling', isOverflowing);
    }

    // Animate text
    const doAnimation = () => {
        if (popupBox.classList.contains('show')) {
            resetAnimation();
        }
        popupBox.classList.add('show');
    }

    const resetAnimation = () => {
        // Hide the popup box without animating it
        popupBox.style.transition = 'none';
        popupBox.classList.remove('show');
        // Trigger reflow to apply the style changes above
        void popupBox.offsetWidth;
        // Prepare to show again with animation
        popupBox.style.transition = '';
    }
    
    const doHotseatAnimation = () => {
        popupText.style.backgroundColor = hotseatBg;
        doAnimation();
    }

    // Animate off
    const deleteAnimation = () => {
        hotSeatIsOn = false;
        popupBox.classList.remove('show');
    }

    function onConnectedHandler (addr, port) {
        console.log(`* Connected to ${addr}:${port}`);
    }
</script>
</html>